# Skill 系统：扫描、加载与执行的全流程（可复刻原理版）

本文只讲“原理/协议”，不绑定任何具体工程结构、目录名或文件名。目标是让另一个 SDK 能基于同样的机制复刻：如何在本地环境中发现 Skills、如何把它们暴露给模型/代理、以及模型如何按需加载并遵循 Skill 的指引完成任务。

## 1. 核心概念与数据模型

### 1.1 Skill 是什么

Skill 是一个“可被按需加载的操作手册”，通常以 Markdown 文档形式存在，并携带结构化元数据（建议用 YAML frontmatter）：

- `name`：全局唯一标识符（用于引用/调用）
- `description`：简短用途说明（用于检索/匹配/展示）
- `content`：正文内容（步骤、约束、最佳实践、注意事项等）
- `location`：Skill 的来源位置（本地路径或其他可解析引用）

实现层面建议把 Skill 拆为两个层次：

- **索引层（Index）**：只保存轻量元数据（`name/description/location`），用于快速列出“有哪些可用技能”
- **内容层（Content）**：正文较长，按需读取/解析，避免一开始就把所有 Skill 内容塞进提示词

### 1.2 Skill 与 Tool 的关系

Skill 本身不直接“执行动作”。它提供**指导**，而“执行动作”由工具系统（例如 bash/edit/read/…）完成。

因此需要一个专门的工具（下称 **Skill Tool**）来：

1) 把“当前可用 skills 列表”展示给模型  
2) 在模型请求时加载某个 skill 的完整内容，并把内容作为 tool 输出返回给模型  

这种设计的关键收益：

- **可扩展**：新 skill 只要放到可扫描位置即可被发现
- **低成本**：不把全部 skill 正文塞进 system prompt，避免上下文膨胀
- **可控**：通过权限系统控制 skill 是否可被加载

## 2. 扫描与发现（Discovery）

### 2.1 扫描根（Scan Roots）

Discovery 的第一步是确定要扫描的“根目录集合”（roots）。一个成熟实现通常同时支持：

- **项目级 roots**：随项目走，用于团队共享（例如项目内的配置/扩展目录）
- **用户级 roots**：用户全局配置目录，用于个人技能库
- **兼容层 roots（可选）**：为了兼容其他生态（例如另一个工具的技能目录约定）
- **显式 roots（可选）**：通过环境变量/启动参数指定额外扫描位置

这些 roots 可以按优先级排序（见 2.4），并且需要考虑“从当前工作目录向上查找”的场景（例如在子目录启动时仍能找到项目级 roots）。

### 2.2 扫描模式（Glob/Pattern）

在每个 root 下，使用约定的模式查找 Skill 文档（manifest）。模式通常包含：

- 支持单数/复数目录（例如 `skill/` 与 `skills/`）
- 支持嵌套子目录（便于按领域分组）
- 只匹配一种约定的入口文件（manifest），避免误扫

扫描时建议：

- 支持 `followSymlinks`（便于共享/复用）
- 明确是否包含 dotfiles（按需）
- 对扫描异常做降级处理：记录错误但不中断整个系统

### 2.3 解析与校验（Parse/Validate）

对每个匹配到的文档：

1) 读取原始文本  
2) 解析 frontmatter（YAML）与正文（Markdown）  
3) 校验最小必需字段：`name` 与 `description`  
4) 写入索引：`index[name] = { name, description, location }`

健壮性建议：

- frontmatter 解析失败要能定位到具体文档并给出可读错误
- 对常见 YAML 易错点做预处理（例如未加引号的 `:` 值导致解析失败），必要时自动转为 block scalar
- 缺失字段或校验不通过的文档：跳过，不纳入可用列表

### 2.4 重名与优先级（Precedence）

重名不可避免（团队/个人/兼容层同时定义同名 skill）。需要定义稳定的覆盖规则：

- “更高优先级 root”覆盖“更低优先级 root”
- 项目级覆盖用户级（或反之，取决于产品定位，但必须一致且可预期）
- 明确兼容层与原生层的关系（例如原生层覆盖兼容层）

实现上可以采用：

- 扫描按优先级顺序执行，后写入覆盖前写入
- 对重名进行日志告警（记录 existing 与 duplicate 的来源位置），方便排查

### 2.5 缓存与失效（Cache/Invalidation）

Discovery 通常比较昂贵，应缓存结果。常见策略：

- 以“项目实例/工作目录上下文”为粒度缓存 skill 索引
- 当工作目录切换、项目实例销毁、配置发生变化时清空/重建缓存

## 3. 暴露给模型（Model-Facing Surface）

### 3.1 Skill Tool 的“自描述”

Skill Tool 初始化时应提供足够的自描述信息，让模型知道：

- 这个工具的用途：加载 skill 获取步骤化指引
- 可用 skill 列表：每个条目至少包含 `name` 与 `description`
- 调用参数 schema：`{ name: string }`

重点是“列出可用 skills”，否则模型不知道有哪些可选项，也无法可靠地选择。

### 3.2 基于 Agent/会话权限裁剪可见列表

同一个运行时可能存在不同权限的 agent（例如只读/完全权限）。因此：

- Skill Tool 在展示可用列表前，先用 agent 的权限规则过滤
- 过滤后的列表才作为“available skills”暴露给模型

这能避免模型“看到但用不了”的技能，也能降低越权风险。

## 4. 加载与执行（Runtime Flow）

从用户输入到 skill 被使用的典型流程如下：

1) **系统启动/进入项目上下文**：完成 skill discovery，得到 skill 索引（只含元数据）  
2) **模型开始对话**：工具系统把 Skill Tool（含可用 skills 列表）提供给模型  
3) **模型决定使用 skill**：调用 Skill Tool，传入目标 `name`  
4) **运行时权限检查**：在真正读取 skill 正文前，向权限系统发起一次 “skill/name” 级别的授权请求  
   - 若规则为 deny：直接拒绝并报错（或返回可恢复错误）  
   - 若规则为 ask：触发交互，让用户选择一次允许/总是允许/拒绝  
   - 若规则为 allow：继续  
5) **加载正文**：根据索引里的 `location` 读取 skill 文档并解析得到正文  
6) **返回 tool 输出**：把 skill 正文作为工具输出返回模型（建议包含少量上下文元数据，例如“该 skill 的根目录/作用域”，用于相对路径/环境假设）  
7) **模型遵循指引执行任务**：模型把 skill 正文当作“任务执行手册”，再按需调用其他工具完成操作  

要点：Skill Tool 本身只负责“把手册递给模型”，真正的文件改动/命令执行仍由其他工具完成，并继续受各自的权限系统约束。

## 5. 权限与安全模型

建议把权限体系设计为“统一的、可复用的判定引擎”，Skill 只是其中一种 permission 类型：

- **权限请求**包含：`permissionType`（例如 "skill"）、`patterns`（例如 skill name）、以及 `always`（用户选择“总是允许”时要记录的模式）
- **规则匹配**建议支持通配符，并采用“最后匹配规则优先”的策略，便于覆盖默认行为
- **交互事件**与**执行线程**解耦：模型/会话可以订阅权限事件，在 UI/CLI 中呈现并回传用户选择

安全边界建议：

- Discovery 只读取并建立索引，不自动把正文注入模型（避免隐式 prompt injection）
- 加载正文必须显式经过 Skill Tool + 权限检查（用户可见、可控）
- Skill 文本属于不可信输入：模型在执行其建议前仍应遵守系统级安全策略（例如敏感命令二次确认等）

## 6. 复刻实现要点（Checklist）

- 设计 Skill 文档协议：元数据（name/description）+ 正文内容
- Discovery：多 root、向上查找、glob 扫描、容错、重名覆盖与告警
- 缓存：以项目上下文为粒度缓存索引；支持失效与重建
- Tool 暴露：Skill Tool 的描述中必须列出可用 skills；参数只需要 `name`
- 权限：Skill Tool 在读取正文前必须走统一权限引擎；支持 ask/allow/deny 以及“always allow”记忆
- 输出：tool 输出返回“结构化标题 + 正文”，并可附带少量元信息帮助解析相对路径/作用域

---

如果你的 SDK 需要进一步对齐行为（例如优先级策略、是否允许 symlink、是否允许兼容层），建议把这些作为“可配置项”而不是硬编码规则。

